# -*- coding: utf-8 -*-
"""Corretor_NLP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/ViniViniAntunes/Corretor_Ortografico_NLP/blob/master/Corretor_NLP.ipynb

# Corretor ortográfico

## 1) Conhecendo o conteúdo do arquivo.
**O arquivo contém o texto de vários artigos publicados na plataforma da Alura. Esse conteúdo será o nosso "corpus".**
**"Corpus", na linguística, é o conjunto de textos escritos e registros orais em uma determinada língua e que serve como base de análise.**

**Primeiro abrimos o arquivo .txt e armazenamos o seu conteúdo em uma variável**
"""

# Abrindo o arquivo txt, armazenando o seu conteúdo em uma variável
with open('treinamento.txt', mode='r') as f:
    treinamento = f.read()

# Mostrando uma parte do conteúdo do arquivo
print(treinamento[:500])

"""**Depois fazemos a "tokenização" que nada mais é que separar o texto em "tokens".**

**Token é uma sequência de caracteres, separados por um limitador, que pode ser um espaço em branco, pontuação ou quebra de linhas, por exemplo.**
"""

# Mostrando quantos caracteres têm no arquivo
len(treinamento)

"""# 2) Fatiando o conteúdo do arquivo
**Precisamos saber quantas palavras existem e não quantos caracteres**

**Usando o método split()**
"""

# Um texto de exemplo
texto_exemplo = 'Olá, tudo bem?'

# "Tokenizando" o texto de exemplo utilizando o método split()
tokens = texto_exemplo.split()

# Mostrando o resultado da "tokenização" do texto de exemplo utilizando o método split()
print(tokens)

# Mostrando o tamanho da lista de tokens criadas no exemplo
len(tokens)

"""**Usando a biblioteca nltk**"""

# Importando a biblioteca nltk
import nltk

# Baixando o pacote punkt
nltk.download('punkt')

# "Tokenizando" o texto de exemplo utilizando a biblioteca nltk
palavras_separadas = nltk.tokenize.word_tokenize(texto_exemplo)

# Mostrando o resultado da "tokenização" do texto de exemplo utilizando a biblioteca nltk
print(palavras_separadas)

# Mostrando o tamanho da lista de tokens criadas no exemplo
len(palavras_separadas)

"""**Podemos notar que, utilizando a bilbioteca nltk, foi possível separar os caracteres especiais das palavras encontradas, mas eles ainda estão todos juntos em uma única lista.**

## 2.1) Separando o necessário

**Separando somente as palavras somente**
"""

# Relembrando como funciona o método isalpha()
'/.'.isalpha()

# Relembrando como funciona o método isalpha()
'à'.isalpha()

# Função separa_palavras()
def separa_palavras(lista_tokens):

    # Criando uma lista vazia para armazenar as palavras separadas dos caracteres especiais
    lista_palavras = []

    # Iterando por toda a lista de tokens
    for token in lista_tokens:

        # Separando as palavras dos caracteres especiais
        if token.isalpha():

            # Armazenando somente as palavras
            lista_palavras.append(token)
    
    # Retornando uma lista somente com as palavras
    return lista_palavras

# Chamando a função separa_palavras para testar
separa_palavras(palavras_separadas)

"""**Teste feito, vamos fazer o mesmo com nosso corpus**"""

# "Tokenizando" o nosso corpus utilizando a biblioteca nltk
lista_tokens = nltk.tokenize.word_tokenize(treinamento)

# Chamando a função separa_palavras() passando o nosso corpus como parâmetro
lista_palavras = separa_palavras(lista_tokens)

# Mostrando o total de palavras em nosso corpus
print(f'O número total de palavras em nosso corpus é {len(lista_palavras)}')

"""**Então em nosso corpus existe tudo isso de palavras???**
<br>
<br>
**A resposta virá na seção 4**
"""

# Uma pequena amostra do resultado até aqui
print(lista_palavras[:5])

"""# 3) Normalização
**Normalizar as palavras é simplesmente deixaá-las noum mesmo padrão, por exemplo, passar todas as letras para minúsculas**
<br>
<br>
**Essa etapa é importante para ajudar o nosso corretor a trabalhar por si só.**

"""

# Função normalizacao() 
def normalizacao(lista_palavras):
    
    # Criando uma lista vazia para armazenar as palavras normalizadas
    lista_normalizada = []

    # Iterando por toda a lista de palavras
    for palavra in lista_palavras:

        # Armazenando as palavras normalizadas
        lista_normalizada.append(palavra.lower())
    
    # Retornando uma lista com as palavras normalizadas
    return lista_normalizada

# Chamando a função normalizacao()
lista_normalizada = normalizacao(lista_palavras)

# Uma pequena amostra do resultado até aqui
print(lista_normalizada[:5])

"""**Note que agora temos somente letras minúsculas**

**Mas quantas palavras de fato existem em nosso corpus?**

**Para responder isso, basta usarmos o método set() do Python**
"""

# Relembrando como funciona o método set() do Python
set([1, 2, 3, 3, 3, 4, 5, 6, 6])

# Mostrando o total real de palavras existentes em nosso corpus
print(f'O número total de palavras que nosso corretor "sabe" de fato é {len(set(lista_normalizada))}')

"""**Segundo esse <a href="https://forum.duolingo.com/comment/7642297/Quantas-palavras-voc%C3%AA-precisa-saber-para-ser-fluente" target="_blank">post</a> no site <a href="https://pt.duolingo.com/" target="_blank">Duolingo</a>, 8000 palavras é mais do que qualquer pessoas precisa saber para ser fluente em uma língua. Nosso corretor está bem acima disso.**

# 4) Preparando o nosso corretor
**Precisamos "ensinar" o nosso corretor a identificar erros para então poder corrigí-los. Faremso isso criando funções e cada tipo de erro um conjunto de funções será criado.**

## 4.1) Erro: falta de uma letra

**Exemplo: supomos que queira digitar a palavra "programação", mas na hora o dedo escapa e digita-se "programaão".  Precisamos fatiar em duas partes a palavra no lugar exato e inserir a letra faltante entre as duas partes**
"""

# Criando um exemplo
palavra_exemplo = 'programaão'

# Relembrando como fatiar uma string em Python
(palavra_exemplo[:8], palavra_exemplo[8:])

# Exemplo do que queremos fazer
print(f'{palavra_exemplo[:8]} + "a letra faltante (ç)" + {palavra_exemplo[8:]}'
      f'\n\nResulta na palavra \n\n\t{palavra_exemplo[:8] + "ç" + palavra_exemplo[8:]}')

"""**Vamos fazer isso para todas as palavras que estiverem faltando uma letra. Precisamos de uma função para fazer isso.**"""

# Função insere_letras()
# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def insere_letras(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito)
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

# Mostrando uma parte da lista que a função insere_letras() retorna como exemplo
insere_letras([('programa', 'ão')])[:5]

# Função gerador_palavras()
def gerador_palavras(palavra):

    # Criando uma lista vazia para armazenar as duas fatias de cada palavra
    fatias = []

    # Iterando por cada letra de cada palavra
    for i in range(len(palavra) + 1):

        # Armazenando as duas fatias em uma tupla e essa tupla em uma lista
        fatias.append((palavra[:i], palavra[i:]))

    # Chamando a função insere_letras() com a lista de tuplas das fatias 
        # recém-criadas e armazenando o retorno dessa função em uma variável
    palavras_geradas = insere_letras(fatias)

    # Retornando a lista de possíveis palavras. A palavra correta estará aí no meio
    return palavras_geradas

# Chamando a função gerador_palavras() com a pallavra_exemplo como parãmetro
    # e armazenando a lista que ela retorna em uma variável
palavras_geradas = gerador_palavras(palavra_exemplo)

# Mostrando, como exemplo, uma parte da lista que a função gerador_palavras() retorna
print(palavras_geradas[:5])

# Laço para mostrar que a palavra correta está aí dentro desta lista
for palavra in palavras_geradas:

    # Selecionando a palavra correta
    if palavra == 'programação':

        # Mostrando que a palavra correta está dentro dessa lista
        print(f'A palavra correta é "{palavra}" e ela está dentro da lista palavras_geradas')

"""**Agora, nosso corretor tem que saber qual é a palavra correta dentro dessas inúmeras palavras geradas**"""

# Mostrando a quantidade de palavras que a função gerador_palavras() 
    # retornou a partir da palavra_exemplo
print(f'Foram geradas {len(palavras_geradas)} palavras')

"""**Faremos isso usando a função FreqDist() da biblioteca nltk. Esse método calcula a frequência que determinada palavra aparece dentro do corpus. Basta darmos qual palavra queremos saber a frequência**"""

# Chamando a função FreqDist() com a lista_normalizada como parâmetro e 
    # armazenando o seu retorno em uma variável
frequencia = nltk.FreqDist(lista_normalizada)

# Calculando o total de palavras e armazenando esse número em uma variável
total_palavras = len(lista_normalizada)

# Mostrando as 10 palavras mais comuns da nossa lista_normalizada
frequencia.most_common(10)

"""**Com isso, podemos calcular a probabilidade de determinada palavra aparecer em nosso corpus**"""

# Função probabilidade()
def probabilidade(palavra_gerada):

    # Retorna a probabilidade de determinada palavra aparecer no nosso corpus
    return frequencia[palavra_gerada] / total_palavras

# Função corretor()
# Recebe como parâmetro a palavra errada (faltando uma letra) e retorna ela corrigida
def corretor(palavra_errada):

    # Chama a função gerador_palavras() usando como parâmetro a palavra 
        # de forma incoreta (digitada com uma letra faltando)
    palavras_geradas = gerador_palavras(palavra_errada)

    # Selecionando a palavra com maior probabilidade de aparecer em nosso corpus
    # Essa será a palavra correta
    palavra_correta = max(palavras_geradas, key=probabilidade)

    # Retornando a palavra corrigida
    return palavra_correta

# Recriando um exemplo, só pra não esquecer. Note que a palavra_exemplo está 
    # digitada incorretamente (faltando uma letra)
palavra_exemplo = 'programaão'

# Testando o nosso corrtor até aqui
corretor(palavra_exemplo)

# Mais testes. Agora com a palavra "lógica"
teste = 'lgica'
print(f'Você quis dizer: {corretor(teste)}')

"""**Com isso nosso corretor está preparado para corrigir palavras digitadas com uma letra falatando.**
<br>
<br>
**Precisamos agora avaliar a qualidade de nosso corretor.**

### Avaliando o nosso corretor
"""

# Função cria_dados_teste()
# Recebe o nome de um arquivo com uma série de palavras digitadas correta e 
    # incorretamente para podermos avaliar o nosso corretor
def cria_dados_teste(nome_arquivo):

    # Criando um lista vazia para armazenar as palavras de teste
    lista_palavras_teste = []

    # Abre o arquivo em mode de leitura
    f = open(nome_arquivo, 'r')

    # Iterando em toda linha do conteúdo do arquivo de teste
    for linha in f:

        # Separando as palavras digitadas correta e incorretamente avaliarmos
        correta, errada = linha.split()

        # Armazenando em uma lista as tuplas formadas pelas palavras 
            # digitadas correta e incorretamente
        lista_palavras_teste.append((correta, errada))
    
    # Fechando o arquivo
    f.close()

    # Retornando a lista com as tuplas de palavras
        # digitadas coreta e incorretamante
    return lista_palavras_teste

# Chamando a função cria_dados_teste() com o nome do arquivo que contém as
    # palavras de teste
lista_teste = cria_dados_teste('palavras.txt')

# Função avaliador()
# Recebe uma lista com as tuplas de palavras de teste para poder
    # avaliar o nosso corretor
def avaliador(testes):

    # Calculando o número de palavras da lista de teste
    numero_palavras = len(testes)

    # Setando um contador
    acertou = 0

    # Iterando por cada tupla dentro da lista de teste
    for correta, errada in testes:

        # Chamando a função corretor() passando cada palavra
            # digitada incorretamente
        palavra_corrigida = corretor(errada)

        # Conferindo cada palavra para ver se ele conseguiu corrigir
        if palavra_corrigida == correta:

            # Incrementando o contador
            acertou += 1
    
    # Calculando a taxa de acerto do nosso corretor
    taxa_acerto = round(acertou * 100 / numero_palavras, 2)

    # Mostrando a taxa de acerto doe nosso corretor
    print(f'{taxa_acerto}% de {numero_palavras} palavras')

# Chamando a função avaliador()
avaliador(lista_teste)

"""**Uma taxa vergonhosamente baixa. Depois de tanto trabalho, nosso corretor acerta 1.08% de 186 palavras teste??**
<br>
<br>
**Tenha em mente que preparamos nosso corretor para corrigir apenas um tipo de erro (o erro de uma letra faltante). Precisamos incrementar mais o nosso corretor.**
<br>
<br>
**Então, mãos à obra!**

### 4.2) Erro: uma letra a mais

**Exemplo: supomos que queira digitar a palavra "programação", mas na hora o dedo pressiona uma tecla vizinha JUNTO àquela que queríamos digitar. "progrsamação". (A tecla "s" é vizinha à tecla "a").**
<br>
<br>
**É uma erro bastante comum, não é mesmo? Para corrigir esse erro, precisamos novamente fatiar em duas partes a palavra no lugar exato e, dessa vez, retirar a letra em excesso que se encontrará na primeira posição da fatia à direita**
"""

# Função deletando_caracter()
# Recebe as fatias
def deletando_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Acrescentando todas as possibilidades de palavras possíveis
        novas_palavras.append(esquerdo + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

# Criando um exemplo para testarmos a nova função
exemplo = [('progr', 'samação')]

# Chamando a função deletando_caracter() passando como parâmetro um exemplo
deletando_caracter(exemplo)

"""**Vamos refatorar a função gerador_palavras() para que ele consiga corrigir também esse novo erro proposto. Assim podemos reaproveitar parte do código.**"""

# Refatorando a função gerador_palavras()
def gerador_palavras(palavra):

    # Criando uma lista vazia para armazenar as duas fatias de cada palavra
    fatias = []

    # Iterando por cada letra de cada palavra
    for i in range(len(palavra) + 1):

        # Armazenando as duas fatias em uma tupla e essa tupla em uma lista
        fatias.append((palavra[:i], palavra[i:]))

    # Chamando a função insere_letras() com a lista de tuplas das fatias 
        # recém-criadas e armazenando o retorno dessa função em uma variável
    palavras_geradas = insere_letras(fatias)

    # Acrescentando mais uma função
    # É aqui que a refatoração de fato ocorre
    palavras_geradas += deletando_caracter(fatias)

    # Retornando a lista de possíveis palavras. A palavra correta estará aí no meio
    return palavras_geradas

# Criando uma palavra de exemplo para testar a nova função gerador_palavras
palavra_exemplo = 'progrsamação'

# Chamando a função gerador_palavras() com a palavra_exemplo como parãmetro
    # e armazenando a lista que ela retorna em uma variável
palavras_geradas = gerador_palavras(palavra_exemplo)

# Mostrando, como exemplo, uma parte da lista que a função gerador_palavras() retorna
print(palavras_geradas[:5])

# Laço para mostrar que a palavra correta está aí dentro desta lista
for palavra in palavras_geradas:

    # Selecionando a palavra correta
    if palavra == 'programação':

        # Mostrando que a palavra correta está dentro dessa lista
        print(f'A palavra correta é "{palavra}" e ela está dentro da lista palavras_geradas')

"""**Agora, nosso corretor tem que saber qual é a palavra correta dentro dessas inúmeras palavras geradas**"""

# Mostrando a quantidade de palavras que a função gerador_palavras() 
    # retornou a partir da palavra_exemplo
print(f'Foram geradas {len(palavras_geradas)} palavras')

"""**Como apenas refatoramos a função gerador_palavras(), o nosso corretor já está preparado para corrigir os dois tipos de erros apresentados.**
<br>
<br>
**Vamos agora avaliar ele novamente para vermos se ele melhora aquele resultado baixíssimo de antes.**
"""

# Chamando a função que avalia o nosso corretor
avaliador(lista_teste)

"""**WOW!!! Foi um belo de um upgrade no resultado, não é mesmo?**
<br>
<br>
**Mas não vamos parar por aqui. Sempre dá para melhorar!!**

## 4.3) Erro: trocando letras

**Exemplo: supomos que queríamos digitar a palavra "programação", mas, sem querer, pressiona uma tecla vizinha NO LUGAR da tecla que corresponde à letra correta que queríamos de fato digitar. "progtamação". (A tecla "t" é vizinha à tecla "r").**
<br>
<br>
**É outro tipo de erro bastante comum e precisamos lidar com ele também. Para corrigir esse erro, precisamos novamente fatiar em duas partes a palavra no lugar exato mas, dessa vez, TROCAR a letra errada pela letra correta.**
"""

# Função trocando_caracter()
# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def troca_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

# Mostrando uma parte da lista que a função trocando_caracter() retorna como exemplo
troca_caracter([('prog', 'tamação')])[:5]

"""**Vamos refatorar mais uma vez a função gerador_palavras() para que ele consiga corrigir também esse novo erro proposto. Assim podemos reaproveitar parte do código.**"""

# Refatorando mais uma vez a função gerador_palavras()
def gerador_palavras(palavra):

    # Criando uma lista vazia para armazenar as duas fatias de cada palavra
    fatias = []

    # Iterando por cada letra de cada palavra
    for i in range(len(palavra) + 1):

        # Armazenando as duas fatias em uma tupla e essa tupla em uma lista
        fatias.append((palavra[:i], palavra[i:]))

    # Chamando a função insere_letras() com a lista de tuplas das fatias 
        # recém-criadas e armazenando o retorno dessa função em uma variável
    palavras_geradas = insere_letras(fatias)

    # Primeira refatoração
    palavras_geradas += deletando_caracter(fatias)

    # Acrescentando outra função
    # É aqui que a segunda refatoração de fato ocorre
    palavras_geradas += troca_caracter(fatias)

    # Retornando a lista de possíveis palavras. A palavra correta estará aí no meio
    return palavras_geradas

# Criando uma palavra de exemplo para testar a nova função gerador_palavras
palavra_exemplo = 'progtamação'

# Chamando a função gerador_palavras() com a palavra_exemplo como parãmetro
    # e armazenando a lista que ela retorna em uma variável
palavras_geradas = gerador_palavras(palavra_exemplo)

# Mostrando, como exemplo, uma parte da lista que a função gerador_palavras() retorna
print(palavras_geradas[:5])

"""**Vamos testá-lo novamente...**"""

# Laço para mostrar que a palavra correta está aí dentro desta lista
for palavra in palavras_geradas:

    # Selecionando a palavra correta
    if palavra == 'programação':

        # Mostrando que a palavra correta está dentro dessa lista
        print(f'A palavra correta é "{palavra}" e ela está dentro da lista palavras_geradas')

"""**Legal! Agora, vamos prepará-lo para mais um erro de digitação.**

## 4.4) Erro: invertendo letras

**Exemplo: supomos que queríamos digitar a palavra "programação". Mas, na pressa, trocamos a letra "g" com a letra "r" resultando em "prorgamação".**
<br>
<br>
**Mais um tipo de erro muito comum que nosso corretor tem que ser capaz de lidar. Para corrigirmos esse erro, precisamos novamente fatiar em duas partes a palavra no lugar exato mas, dessa vez, TROCAR AS POSIÇÕES das letras de index 0 com a letra de index 1 da fatia direita.**
<br>
<br>
**Você notou que estamos refatorando bastante o código do nosso corretor para aproveitar coisas já escritas anteriormente. Para esse erro, será bem parecido, então para facilitar, juntaremos todas as funcões que corrigem erros numa única célula do notebook.**

**Façamos isso então...**
"""

########################### Função insere_letras() ############################

# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def insere_letras(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito)
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################## Função deletando_caracter() ##########################

# Função deletando_caracter()
# Recebe as fatias
def deletando_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Acrescentando todas as possibilidades de palavras possíveis
        novas_palavras.append(esquerdo + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################## Função trocando_caracter() ###########################

# Função trocando_caracter()
# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def troca_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

####################### Função invertendo_caracter() ##########################

# Função invertendo_caracter()
# Recebe as fatias
def invertendo_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:
        
        # Selecionando apenas as fatias da direita que têm mais de uma letra, 
            # pois, se não, não há o que inverter
        if len(direito) > 1:
            
            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + direito[1] + direito[0] + direito[2:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################### Função gerador_palavras() ###########################

# Refatorando outra vez a função gerador_palavras()
def gerador_palavras(palavra):

    # Criando uma lista vazia para armazenar as duas fatias de cada palavra
    fatias = []

    # Iterando por cada letra de cada palavra
    for i in range(len(palavra) + 1):

        # Armazenando as duas fatias em uma tupla e essa tupla em uma lista
        fatias.append((palavra[:i], palavra[i:]))

    # Chamando a função insere_letras() com a lista de tuplas das fatias 
        # recém-criadas e armazenando o retorno dessa função em uma variável
    palavras_geradas = insere_letras(fatias)

    # Primeira refatoração
    palavras_geradas += deletando_caracter(fatias)

    # Segunda refatoração de fato ocorre
    palavras_geradas += troca_caracter(fatias)

    # Acrescentando outra função
    # É aqui que a terceira refatoração de fato ocorre
    palavras_geradas += invertendo_caracter(fatias)

    # Retornando a lista de possíveis palavras. A palavra correta estará aí no meio
    return palavras_geradas

"""**Avaliando o nosso coretor.**"""

################################# AVALIANDO ###################################

# Criando uma palavra de exemplo para testar a nova função gerador_palavras
# Note o novvo erro de digitação
palavra_exemplo = 'prorgamação'

# Chamando a função gerador_palavras() com a palavra_exemplo como parãmetro
    # e armazenando a lista que ela retorna em uma variável
palavras_geradas = gerador_palavras(palavra_exemplo)

# Mostrando, como exemplo, uma parte da lista que a função gerador_palavras() retorna
print(palavras_geradas[:5])

# Laço para mostrar que a palavra correta está aí dentro desta lista
for palavra in palavras_geradas:

    # Selecionando a palavra correta
    if palavra == 'programação':

        # Mostrando que a palavra correta está dentro dessa lista
        print(f'A palavra correta é "{palavra}" e ela está dentro da lista palavras_geradas')

"""**Pronto! Nosso corretor já está preparado para corrigir os quatro tipos de erros apresentados.**
<br>
<br>
**Avaliá-lo-emos novamente para ver o seu resultado.**
"""

# Chamando a função que avalia o nosso corretor
avaliador(lista_teste)

"""**YEAH!!! Mais um belo salto no resultado do teste.**

**Nosso corretor está indo muito bem, porém há uma dúvida.**
<br>
<br>
**Nosso algoritmo "conhece" um vocabulário, aquele que vem do nosso corpus. E os testes que estamos fazendo vêm de uma lista de palavras.**
<br>
<br>
**Então, podem haver palavras nessa lista que nosso algoritmo não conheça, certo? Logo, esses 23.66% de erro estão associados tanto ao erro real do corretor, quanto ao "erro" de desconhecer determinada palavra. Como ele fará a correção daquilo que ele não conhece?**

**Primeiramente, precisamos saber qual é a porcentagem que corresponde ao desconhecimento de determinadas palavras.**
<br>
<br>
**Então vamos refatorar a função avaliador para que ela possa nos fornecer também essa a porcentagem.**
"""

# Função avaliador()
# Recebe uma lista com as tuplas de palavras de teste para poder
    # avaliar o nosso corretor
def avaliador(testes, vocabulario):

    # Calculando o número de palavras da lista de teste
    numero_palavras = len(testes)

    # Setando os contadores
    acertou = desconhecidas = 0

    # Iterando por cada tupla dentro da lista de teste
    for correta, errada in testes:

        # Chamando a função corretor() passando cada palavra
            # digitada incorretamente
        palavra_corrigida = corretor(errada)

        # Incrementando o contador das palavras desconhecidas
        desconhecidas += (correta not in vocabulario)
        
        # Conferindo cada palavra para ver se ele conseguiu corrigir
        if palavra_corrigida == correta:

            # Incrementando o contador das palavras corretas
            acertou += 1
    
    # Calculando a taxa de acerto do nosso corretor
    taxa_acerto = round(acertou * 100 / numero_palavras, 2)

    # Calculando a taxa de erro referente às palavras desconhecidas
    taxa_desconhecidas = round(desconhecidas * 100 / numero_palavras, 2)

    # Mostrando a taxa de acerto doe nosso corretor
    print(f'{taxa_acerto}% de {numero_palavras} das palavras conhecidas\n'
          f'e {taxa_desconhecidas}% das palavras desconhecidas')

# Calculando as palavras conecidas
vocabulario = set(lista_normalizada)

# Chamando a função avaliador()
avaliador(lista_teste, vocabulario)

"""**Pronto! Agora sabemos que 6.99% das palavras avaliadas são desconhecidas pelo nosso corretor.**

## 4.5) Erro: palavras a duas letras de distância da palavra correta

**Até agora, o nosso corretor consegue corrigir palavras que estão a uma única distância da palavras correta. Ou seja, ele só consegue corrigir palavras com apenas uma letra errada a mais ou a menos.**
<br>
<br>
**Por exemplo, quando digitamos "prorrgramação" ao invés de "programação".**

**Veja que, o jeito que está, nosso corretor não consegue corrigir esse tipo de problema.**
"""

palavra_exemplo = 'prorrgramação'
corretor(palavra_exemplo)

"""**Vamos trabalhar um pouco mais no algortimo do nosso corretor para que ele seja capaz de corrigir as palavras que estão a duas letras distância da palavra correta.**"""

# Função gerador_inception()
def gerador_inception(palavras_geradas):

    # Criando uma nova lista para armazenar as novas palavras
    novas_palavras = []

    # Iterando em cada palavra da lista recebida
    for palavra in palavras_geradas:

        # Chamando a função gerador_palavras() aqui dentro da nova função
            # Por isso o nome gerador_inception()
        novas_palavras += gerador_palavras(palavra)
    
    # Retornando as novas palavras
    return novas_palavras

"""**Porém, o retorno  dessa função gerador_inception() é muito grande. E como teremos que calcular a probabilidade de cada uma dessas palavras aparecer em nosso corpus, estamos sobrecarregando o nosso corretor com cálculos desnecessários, já que a imensa maioria das palavras aí geradas são palavras que não existem.**
<br>
<br>
**Vejamos...**
"""

# Calculando o número de palavras geradas ao chamar a função gerador_palavras()
    # dentro da função gerador_inception()
palavras_geradas = gerador_inception(gerador_palavras(palavra_exemplo))
print(f'A quantidade de possíveis palavras geradas é {len(palavras_geradas)}')

"""**E aí dentro dessa imensidão de palavras, está a palavra correta. Porém, tem muito lixo.**"""

# Mostrando que a palavra correta está nesse monte de lixo

'programação' in palavras_geradas

"""**Então, vamos criar uma nova função corretor que não precise calcular a probabilidade de tantas palavras que nem existem. Vamos chamá-la de corretor_super_sayajin()**"""

# Função corretor_super_sayajin()
# Recebe como parâmetro a palavra errada e retorna ela corrigida
def corretor_super_sayajin(palavra_errada):

    # Chama a função gerador_palavras() usando como parâmetro a palavra 
        # escrita de forma incorreta
    palavras_geradas = gerador_palavras(palavra_errada)

    # Chamando a função gerador_inception() e armazenando o seu retorno
        # em uma variável
    palavras_inception = gerador_inception(palavras_geradas)

    # Juntando todas as palavras geradas
    todas_palavras = set(palavras_geradas + palavras_inception)

    # Criando uma lista para armazenar os possíveis candidatos a palavra 
    candidatos = [palavra_errada]

    # Iterando por todas as palavras geradas pelas duas funções
    for palavra in todas_palavras:

        # Verificando se a palavra já se encontra no vocabulário
        if palavra in vocabulario:

            # Adicionando a palvara a lista de candidatos
            candidatos.append(palavra)

    # Mostrando quantos e quais são os candidatos
    print(f'Temos {len(candidatos)} candidatos a palavra correta.\n'
          f'São eles {candidatos}')

    # Selecionando a palavra com maior probabilidade de aparecer em nosso corpus
        # Essa será a palavra correta
    palavra_correta = max(candidatos, key=probabilidade)

    # Retornando a palavra corrigida
    return palavra_correta

"""**Pronto! Agora, vamos comparar a antiga função corretor() com a nova função corretor_super_sayajin()**"""

# Chamando a função antiga função corretor()
antes = corretor(palavra_exemplo)

# Mostrando o retorno da antiga função corretor()
print('Antiga função corretor()\n'
      '========================\n\n'
     f'Entrada ==> {palavra_exemplo}\n'
     f'Retorno ==> {antes}')

# Um print() para melhor visualizar os resultados
print('Com a novoa função corretor_super_sayajin():\n')

# Chamando a função nova função corretor_super_sayajin()
depois = corretor_super_sayajin(palavra_exemplo)

# Mostrando o retorno da nova função corretor_super_sayajin()
print('\nNova função nova função corretor_super_sayajin()\n'
      '==============================================\n\n'
     f'Entrada ==> {palavra_exemplo}\n'
     f'Retorno ==> {depois}')

"""# 5) Avaliando os resultados do corretor final e concluindo

## 5.1) Avaliando

**Antes de avaliar a nova função corretor_super_sayajin() utilizando a lista_teste, precisamos retirar o print() que existe dentro da nova função corretor_super_sayajin(), para que ela não imprima na tela quantos e quais são os possíveis candidatos para todas as 186 palavras que ele irá testar.**
"""

# Função corretor_super_sayajin()
# Recebe como parâmetro a palavra errada e retorna ela corrigida
def corretor_super_sayajin(palavra_errada):

    # Chama a função gerador_palavras() usando como parâmetro a palavra 
        # escrita de forma incorreta
    palavras_geradas = gerador_palavras(palavra_errada)

    # Chamando a função gerador_inception() e armazenando o seu retorno
        # em uma variável
    palavras_inception = gerador_inception(palavras_geradas)

    # Juntando todas as palavras geradas
    todas_palavras = set(palavras_geradas + palavras_inception)

    # Criando uma lista para armazenar os possíveis candidatos a palavra 
    candidatos = [palavra_errada]

    # Iterando por todas as palavras geradas pelas duas funções
    for palavra in todas_palavras:

        # Verificando se a palavra já se encontra no vocabulário
        if palavra in vocabulario:

            # Adicionando a palvara a lista de candidatos
            candidatos.append(palavra)

    # Selecionando a palavra com maior probabilidade de aparecer em nosso corpus
        # Essa será a palavra correta
    palavra_correta = max(candidatos, key=probabilidade)

    # Retornando a palavra corrigida
    return palavra_correta

# Mostrando que a nova função corretor_super_sayajin() não imprime mais 
    # quantos e quias são os possíveis candidatos
corretor_super_sayajin(palavra_exemplo)

"""**E precisamos também, dentro da função avaliador(), trocar o nome da função corretor() para corretor_super_sayajin()**"""

# Função avaliador()
# Recebe uma lista com as tuplas de palavras de teste para poder
    # avaliar o nosso corretor
def avaliador(testes, vocabulario):

    # Calculando o número de palavras da lista de teste
    numero_palavras = len(testes)

    # Setando os contadores
    acertou = desconhecidas = 0

    # Iterando por cada tupla dentro da lista de teste
    for correta, errada in testes:

        # Chamando a função corretor() passando cada palavra
            # digitada incorretamente
        palavra_corrigida = corretor_super_sayajin(errada)

        # Incrementando o contador das palavras desconhecidas
        desconhecidas += (correta not in vocabulario)
        
        # Conferindo cada palavra para ver se ele conseguiu corrigir
        if palavra_corrigida == correta:

            # Incrementando o contador das palavras corretas
            acertou += 1
    
    # Calculando a taxa de acerto do nosso corretor
    taxa_acerto = round(acertou * 100 / numero_palavras, 2)

    # Calculando a taxa de erro referente às palavras desconhecidas
    taxa_desconhecidas = round(desconhecidas * 100 / numero_palavras, 2)

    # Mostrando a taxa de acerto doe nosso corretor
    print(f'{taxa_acerto}% de {numero_palavras} das palavras conhecidas\n'
          f'e {taxa_desconhecidas}% das palavras desconhecidas')

# Calculando as palavras conecidas
vocabulario = set(lista_normalizada)

# Chamando a função avaliador()
avaliador(lista_teste, vocabulario)

"""**Oh não! Caiu demais a taxa de acerto!**
<br>
<br>
**Vamos ver o que aconteceu imprimindo, para cada palavra testada:**
<br>
<br>
**a palavra errada - a corrigida pela antiga função corretor() - a corrigida pela nova função corretor_super_sayajin()**
"""

# Função avaliador()
# Recebe uma lista com as tuplas de palavras de teste para poder
    # avaliar o nosso corretor
def avaliador(testes, vocabulario):

    # Calculando o número de palavras da lista de teste
    numero_palavras = len(testes)

    # Setando os contadores
    acertou = desconhecidas = 0

    # Iterando por cada tupla dentro da lista de teste
    for correta, errada in testes:

        # Chamando a função corretor() passando cada palavra
            # digitada incorretamente
        palavra_corrigida = corretor_super_sayajin(errada)

        # Incrementando o contador das palavras desconhecidas
        desconhecidas += (correta not in vocabulario)
        
        # Conferindo cada palavra para ver se ele conseguiu corrigir
        if palavra_corrigida == correta:

            # Incrementando o contador das palavras corretas
            acertou += 1

        #
        else:
            print(f"{errada} - {corretor(errada)} - {palavra_corrigida}")
    
    # Calculando a taxa de acerto do nosso corretor
    taxa_acerto = round(acertou * 100 / numero_palavras, 2)

    # Calculando a taxa de erro referente às palavras desconhecidas
    taxa_desconhecidas = round(desconhecidas * 100 / numero_palavras, 2)

    # Mostrando a taxa de acerto doe nosso corretor
    print(f'\n\n{taxa_acerto}% de {numero_palavras} das palavras conhecidas\n'
          f'e {taxa_desconhecidas}% das palavras desconhecidas')

# Calculando as palavras conecidas
vocabulario = set(lista_normalizada)

# Chamando a função avaliador()
avaliador(lista_teste, vocabulario)

"""**Com esse print(), podemos notar que um dos motivos de o novo corretor se sai pior que o antigo, é porque os erros que o mais jovem gera estão associados ao fato dele gerar tanto a possível palavra correta quanto uma variação existente no vocabulário que apresente maior frequência. Se a frequência for maior, a probabilidade de ser a palavra correta também é maior. Por isso, ele apresenta mais erros quando testado nessa lista_teste.**

**Outro motivo dos erros associados ao novo corretor é a restrição imposta pelo vocabulário do corretor, ou seja, a fonte dos dados em que ele foi treinado.**
<br>
<br>
**Repare que nós não modificamos a base de treinamento do corretor, assim, ainda existe uma parcela do erro devido às limitações do vocabulário.**

## 5.2) Conclusão

<br>
<br>

**Para a nossa base de dados de treinamento e de avaliação, o corretor() se saiu bem melhor que o corretor_super_sayajin() apesar de o segundo estar preparado para um tipo de erro a mais que o primeiro.**

# 6) Preparando o melhor corretor

**Vamos juntar os códigos do melhor corretor para organizar.**
"""

########################### Função insere_letras() ############################

# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def insere_letras(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito)
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################## Função deletando_caracter() ##########################

# Função deletando_caracter()
# Recebe as fatias
def deletando_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Acrescentando todas as possibilidades de palavras possíveis
        novas_palavras.append(esquerdo + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################## Função trocando_caracter() ###########################

# Função trocando_caracter()
# Recebe uma lista de tuplas (esquerdo, direito) que corresponde aos lados 
    # esquerdo e direito da palavra fatiada em dois
def troca_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Variável que armazena todas as letras do alfabeto e as vogais acentuadas
        # É daqui que nosso corretor pegará a letra faltante
    letras = 'abcedfghijklmnopqrstuvwxyzáâàãéêèíîìóôòõúûùç'

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:

        # Iterando por toda letra das variável letras
        for letra in letras:

            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + letra + direito[1:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

####################### Função invertendo_caracter() ##########################

# Função invertendo_caracter()
# Recebe as fatias
def invertendo_caracter(fatias):

    # Criando uma lista vazia para armazenar as palavras corrigidas
    novas_palavras = []

    # Iterando por todas as tuplas da lista recebida
    for esquerdo, direito in fatias:
        
        # Selecionando apenas as fatias da direita que têm mais de uma letra, 
            # pois, se não, não há o que inverter
        if len(direito) > 1:
            
            # Acrescentando todas as possibilidades de palavras possíveis
            novas_palavras.append(esquerdo + direito[1] + direito[0] + direito[2:])
    
    # Retornando uma lista de possíveis palavras
    return novas_palavras

######################### Função gerador_palavras() ###########################

# Refatorando outra vez a função gerador_palavras()
def gerador_palavras(palavra):

    # Criando uma lista vazia para armazenar as duas fatias de cada palavra
    fatias = []

    # Iterando por cada letra de cada palavra
    for i in range(len(palavra) + 1):

        # Armazenando as duas fatias em uma tupla e essa tupla em uma lista
        fatias.append((palavra[:i], palavra[i:]))

    # Chamando a função insere_letras() com a lista de tuplas das fatias 
        # recém-criadas e armazenando o retorno dessa função em uma variável
    palavras_geradas = insere_letras(fatias)

    # Primeira refatoração
    palavras_geradas += deletando_caracter(fatias)

    # Segunda refatoração de fato ocorre
    palavras_geradas += troca_caracter(fatias)

    # Acrescentando outra função
    # É aqui que a terceira refatoração de fato ocorre
    palavras_geradas += invertendo_caracter(fatias)

    # Retornando a lista de possíveis palavras. A palavra correta estará aí no meio
    return palavras_geradas

############################# Função avaliador() ###############################

# Função avaliador()
# Recebe uma lista com as tuplas de palavras de teste para poder
    # avaliar o nosso corretor
def avaliador(testes, vocabulario):

    # Calculando o número de palavras da lista de teste
    numero_palavras = len(testes)

    # Setando os contadores
    acertou = desconhecidas = 0

    # Iterando por cada tupla dentro da lista de teste
    for correta, errada in testes:

        # Chamando a função corretor() passando cada palavra
            # digitada incorretamente
        palavra_corrigida = corretor(errada)

        # Incrementando o contador das palavras desconhecidas
        desconhecidas += (correta not in vocabulario)
        
        # Conferindo cada palavra para ver se ele conseguiu corrigir
        if palavra_corrigida == correta:

            # Incrementando o contador das palavras corretas
            acertou += 1
    
    # Calculando a taxa de acerto do nosso corretor
    taxa_acerto = round(acertou * 100 / numero_palavras, 2)

    # Calculando a taxa de erro referente às palavras desconhecidas
    taxa_desconhecidas = round(desconhecidas * 100 / numero_palavras, 2)

    # Mostrando a taxa de acerto doe nosso corretor
    print(f'{taxa_acerto}% de {numero_palavras} das palavras conhecidas\n'
          f'e {taxa_desconhecidas}% das palavras desconhecidas')

# Calculando as palavras conecidas
vocabulario = set(lista_normalizada)

# Chamando a função avaliador()
avaliador(lista_teste, vocabulario)

"""# 7) Teste e divirta-se!"""

# Digite aqui a sua palavra incorreta
teste = 'odontoolgia'

# Mostrando as respostas dos dois corretores
print(f'Entrada =================> {teste}\nResposta do corretor() ==> {corretor(teste)}')

